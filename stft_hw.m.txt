function [S, f, t] = stft_hw(signal, window_size, hop_size, Fs)
    
    %% Input
    % 1) s : signal
    % 2) window_size : the size of the window used for dividing the signal
    % into segments
    % 3) hop_size : number of samples between two consecutive windows
    % 4) Fs : sampling frequency

    %% Output
    % 1) S : STFT Matrix. It contains the coefficients of the tranform for
    % each frame and frequency
    % 2) f : frequencies vector that correspond to the FFT bins
    % 3) t : times vector that correspond to the centers of each analyzed
    % frame
    
    %% parameters
    
    window = hamming(window_size);  % Hamming window
    num_samples = length(signal);  % number of samples
    num_frames = 1 + floor((num_samples - window_size) / hop_size);  % number of frames
    S = complex(zeros(floor(window_size / 2) + 1, num_frames));  % STFT Matrix

    %% Loop over the frames
    for k = 0:num_frames-1

        % Calculate the start and end indexes of the current segment of the
        % signal
        start_idx = k * hop_size + 1;
        end_idx = start_idx + window_size - 1;
        
        % Extract the signal segment and multiply it for the Hamming window
        % in order to minimize the edge effects
        frame = signal(start_idx:end_idx) .* window;

        % Calculate the FFT of the frame
        %X = fft_hw(frame);
        X = fft(frame, window_size);

        % Save the FFT part that goes from the DC component to the Nyquist
        % component in the STFT result
        S(:, k + 1) = X(1:floor(window_size / 2) + 1);
    end
    
    %% Temporal and frequency vectors
    % Create a times vector that represents the temporal center of each
    % frame, calculated as the hop sie divided by the sampling frequency
    t = (0:num_frames-1) * hop_size / Fs;

    % Create a frequencies vector for the FFT bins that goes from 0 until
    % the Nyquist frequency
    f = (0:floor(window_size / 2)) * Fs / window_size;
end
